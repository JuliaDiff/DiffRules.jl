const AS = Union{AbstractArray{<:Real}, Real}

"""
    check_errs(f, ∇f, Ȳ::AS, X::AS, V::AS, ε_abs::Real=1e-7, ε_rel::Real=1e-5)::Bool
"""
check_errs(f, ∇f, Ȳ::AS, X::AS, V::AS, ε_abs::Real=1e-7, ε_rel::Real=1e-5)::Bool =
    assert_approx_equal(
        central_fdm(2, 1)(ϵ->sum(Ȳ .* f(X + ϵ * V))),
        sum(∇f(f(X), Ȳ, X) .* V),
        ε_abs, ε_rel)

"""
    check_errs(N::Int, f, ∇f, Ȳ, X, V, ε_abs=1e-7, ε_rel=1e-5)::Bool

Call check_errs `N` times with arguments generated by 0-ary functions `Ȳ`, `X` and `V`.
"""
check_errs(N::Int, f, ∇f, Ȳ, X, V, ε_abs=1e-7, ε_rel=1e-5)::Bool =
    all(map(n->check_errs(f, ∇f, Ȳ(), X(), V(), ε_abs, ε_rel), 1:N))


# Utility to create the closures required for unit testing.
unary_ȲD(f) = (f, (Y, Ȳ, X)->∇(f, Val{1}, (), Y, Ȳ, X))
unary_ȲD_inplace(f, X̄0) = (f, (Y, Ȳ, X)->∇(copy(X̄0), f, Val{1}, (), Y, Ȳ, X) - X̄0)
function binary_ȲD(f, arg::Int, G)
    G_ = G()
    if arg == 1
        return X->f(X, G_), (Y, Ȳ, X)->∇(f, Val{1}, (), Y, Ȳ, X, G_)
    else
        return X->f(G_, X), (Y, Ȳ, X)->∇(f, Val{2}, (), Y, Ȳ, G_, X)
    end
end
function binary_ȲD_inplace(f, arg::Int, G, X̄0)
    G_ = G()
    if arg == 1
        return X->f(X, G_), (Y, Ȳ, X)->∇(copy(X̄0), f, Val{1}, (), Y, Ȳ, X, G_) - X̄0
    else
        return X->f(G_, X), (Y, Ȳ, X)->∇(copy(X̄0), f, Val{2}, (), Y, Ȳ, G_, X) - X̄0
    end
end
