var documenterSearchIndex = {"docs":
[{"location":"#DiffRules","page":"Documentation","title":"DiffRules","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"CurrentModule = DiffRules","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Many differentiation methods rely on the notion of \"primitive\" differentiation rules that can be composed via various formulations of the chain rule. Using DiffRules, you can define new differentiation rules, query whether or not a given rule exists, and symbolically apply rules to simple Julia expressions.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Note that DiffRules is not a fully-fledged symbolic differentiation tool. It is a (very) simple global database of common derivative definitions, and was developed with the goal of improving derivative coverage in downstream tools.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"DiffRules.@define_diffrule\nDiffRules.diffrule\nDiffRules.hasdiffrule\nDiffRules.diffrules","category":"page"},{"location":"#DiffRules.@define_diffrule","page":"Documentation","title":"DiffRules.@define_diffrule","text":"@define_diffrule M.f(x) = :(df_dx($x))\n@define_diffrule M.f(x, y) = :(df_dx($x, $y)), :(df_dy($x, $y))\nâ‹®\n\nDefine a new differentiation rule for the function M.f and the given arguments, which should be treated as bindings to Julia expressions. Return the defined rule's key.\n\nThe LHS should be a function call with a non-splatted argument list, and the RHS should be the derivative expression, or in the n-ary case, an n-tuple of expressions where the ith expression is the derivative of f w.r.t the ith argument. Arguments should be interpolated wherever they are used on the RHS.\n\nNote that differentiation rules are purely symbolic, so no type annotations should be used.\n\nExamples\n\n@define_diffrule Base.cos(x)          = :(-sin($x))\n@define_diffrule Base.:/(x, y)        = :(inv($y)), :(-$x / ($y^2))\n@define_diffrule Base.polygamma(m, x) = :NaN,       :(polygamma($m + 1, $x))\n\n\n\n\n\n","category":"macro"},{"location":"#DiffRules.diffrule","page":"Documentation","title":"DiffRules.diffrule","text":"diffrule(M::Union{Expr,Symbol}, f::Symbol, args...)\n\nReturn the derivative expression for M.f at the given argument(s), with the argument(s) interpolated into the returned expression.\n\nIn the n-ary case, an n-tuple of expressions will be returned where the ith expression is the derivative of f w.r.t the ith argument.\n\nExamples\n\njulia> DiffRules.diffrule(:Base, :sin, 1)\n:(cos(1))\n\njulia> DiffRules.diffrule(:Base, :sin, :x)\n:(cos(x))\n\njulia> DiffRules.diffrule(:Base, :sin, :(x * y^2))\n:(cos(x * y ^ 2))\n\n\n\n\n\n","category":"function"},{"location":"#DiffRules.hasdiffrule","page":"Documentation","title":"DiffRules.hasdiffrule","text":"hasdiffrule(M::Union{Expr,Symbol}, f::Symbol, arity::Int)\n\nReturn true if a differentiation rule is defined for M.f and arity, or return false otherwise.\n\nHere, arity refers to the number of arguments accepted by f.\n\nExamples\n\njulia> DiffRules.hasdiffrule(:Base, :sin, 1)\ntrue\n\njulia> DiffRules.hasdiffrule(:Base, :sin, 2)\nfalse\n\njulia> DiffRules.hasdiffrule(:Base, :-, 1)\ntrue\n\njulia> DiffRules.hasdiffrule(:Base, :-, 2)\ntrue\n\njulia> DiffRules.hasdiffrule(:Base, :-, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#DiffRules.diffrules","page":"Documentation","title":"DiffRules.diffrules","text":"diffrules(; filter_modules=(:Base, :SpecialFunctions, :NaNMath))\n\nReturn a list of keys that can be used to access all defined differentiation rules for modules in filter_modules.\n\nEach key is of the form (M::Symbol, f::Symbol, arity::Int). Here, arity refers to the number of arguments accepted by f and M is one of the modules in filter_modules.\n\nTo include all rules, specify filter_modules = nothing.\n\nnote: Note\nCalling diffrules() with the implicit default keyword argument filter_modules does not return all rules defined by this package but rather only rules for the packages for which DiffRules 1.0 provided rules. This is done in order to not to break downstream packages that assumed this list would never change. It is planned to change diffrules() to return all rules, i.e., to use the default keyword argument filter_modules=nothing, in an upcoming breaking release of DiffRules.\n\nExamples\n\njulia> first(DiffRules.diffrules()) isa Tuple{Symbol,Symbol,Int}\ntrue\n\njulia> (:Base, :log, 1) in DiffRules.diffrules()\ntrue\n\njulia> (:Base, :*, 2) in DiffRules.diffrules()\ntrue\n\nIf you call diffrules(), only rules for Base, SpecialFunctions, and NaNMath are returned but no rules for LogExpFunctions:\n\njulia> any(M === :LogExpFunctions for (M, _, _) in DiffRules.diffrules())\nfalse\n\nIf you set filter_modules=nothing, all rules defined in DiffRules are returned and in particular also rules for LogExpFunctions:\n\njulia> any(\n           M === :LogExpFunctions\n           for (M, _, _) in DiffRules.diffrules(; filter_modules=nothing)\n       )\ntrue\n\nIf you set filter_modules=(:Base,) only rules for functions in Base are returned:\n\njulia> all(M === :Base for (M, _, _) in DiffRules.diffrules(; filter_modules=(:Base,)))\ntrue\n\n\n\n\n\n","category":"function"}]
}
